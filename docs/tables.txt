:mod:`formalchemy.tables` -- Rendering collections
==================================================

.. automodule:: formalchemy.tables

Besides :class:`~formalchemy.forms.FieldSet`, `FormAlchemy` provides `Grid` for editing and
rendering multiple instances at once.  Most of what you know about
:class:`~formalchemy.forms.FieldSet` applies to `Grid`, with the following differences to
accomodate being bound to multiple objects:

The Grid class
--------------

.. autoclass:: Grid
   :members:


Configuration
-------------

The `Grid` `configure` method takes the same arguments as :class:`~formalchemy.forms.FieldSet`
(`pk`, `exclude`, `include`, `options`, `readonly`), except there is
no `focus` argument.

Validation and Sync
-------------------

These are the same as in :class:`~formalchemy.forms.FieldSet`, except that you can also call
`sync_one(instance)` to sync a single one of the instances that are
bound to the `Grid`.

The `Grid` `errors` attribute is a dictionary keyed by bound instance,
whose value is similar to the `errors` from a :class:`~formalchemy.forms.FieldSet`, that is, a
dictionary whose keys are `Field`s, and whose values are
`ValidationError` instances.

Customizing Grid
----------------

Overriding `Grid` rendering is similar to :class:`~formalchemy.forms.FieldSet`.  The differences are:

  * The default templates take a `collection` parameter instead of `fieldset`, which is the instance of `Grid` to render
  * The instances given to the collection are available in `collection.rows`; to access the fields of each single row, call `_set_active(row)`, then access `render_fields`.

The default templates are `formalchemy.tables.template_grid_readonly` and `formalchemy.tables.template_grid`.

Usage
-----

You need some imports::

  >>> from formalchemy.tables import *

.. Hidden code needed for testing

  >>> from formalchemy.tests import *
  >>> from formalchemy.tables import Grid as Base
  >>> class Grid(Base):
  ...     def render(self):
  ...         return pretty_html(Base.render(self))

Then you can initialize a `Grid` and bind it to a list of row instance::  

  >>> tc = Grid(User, [bill])
  >>> tc.configure(readonly=True)

This will render instances as an html table::

  >>> print tc.render()
  <thead>
   <tr>
    <th>
     Email:
    </th>
    <th>
     Password:
    </th>
    <th>
     Name:
    </th>
    <th>
     Orders:
    </th>
   </tr>
  </thead>
  <tbody>
   <tr>
    <td>
     bill@example.com
    </td>
    <td>
     1234
    </td>
    <td>
     Bill
    </td>
    <td>
     Quantity: 10
    </td>
   </tr>
  </tbody>

You can also add a field to the `Grid` manually::

  >>> tc2 = Grid(User, [bill, john])
  >>> tc2.add(Field('link', type=types.String, value=lambda item: '<a href=%d>link</a>' % item.id))
  >>> tc2.configure(readonly=True)
  >>> print tc2.render()
  <thead>
   <tr>
    <th>
     Email:
    </th>
    <th>
     Password:
    </th>
    <th>
     Name:
    </th>
    <th>
     Orders:
    </th>
    <th>
     Link:
    </th>
   </tr>
  </thead>
  <tbody>
   <tr>
    <td>
     bill@example.com
    </td>
    <td>
     1234
    </td>
    <td>
     Bill
    </td>
    <td>
     Quantity: 10
    </td>
    <td>
     <a href="1">
      link
     </a>
    </td>
   </tr>
   <tr>
    <td>
     john@example.com
    </td>
    <td>
     5678
    </td>
    <td>
     John
    </td>
    <td>
     Quantity: 5, Quantity: 6
    </td>
    <td>
     <a href="2">
      link
     </a>
    </td>
   </tr>
  </tbody>

You can also rebind a existing `Grid`::

  >>> g = Grid(User)
  >>> g.rebind([bill, john]) # explicitly test rebind
  >>> print g.render()
  <thead>
   <tr>
    <th>
     Email:
    </th>
    <th>
     Password:
    </th>
    <th>
     Name:
    </th>
    <th>
     Orders:
    </th>
   </tr>
  </thead>
  <tbody>
   <tr>
    <td>
     <input id="User-1-email" maxlength="40" name="User-1-email" type="text" value="bill@example.com" />
    </td>
    <td>
     <input id="User-1-password" maxlength="20" name="User-1-password" type="text" value="1234" />
    </td>
    <td>
     <input id="User-1-name" maxlength="30" name="User-1-name" type="text" value="Bill" />
    </td>
    <td>
     <select id="User-1-orders" multiple="multiple" name="User-1-orders" size="5">
      <option value="1" selected="selected">
       Quantity: 10
      </option>
      <option value="2">
       Quantity: 5
      </option>
      <option value="3">
       Quantity: 6
      </option>
     </select>
    </td>
   </tr>
   <tr>
    <td>
     <input id="User-2-email" maxlength="40" name="User-2-email" type="text" value="john@example.com" />
    </td>
    <td>
     <input id="User-2-password" maxlength="20" name="User-2-password" type="text" value="5678" />
    </td>
    <td>
     <input id="User-2-name" maxlength="30" name="User-2-name" type="text" value="John" />
    </td>
    <td>
     <select id="User-2-orders" multiple="multiple" name="User-2-orders" size="5">
      <option value="1">
       Quantity: 10
      </option>
      <option value="2" selected="selected">
       Quantity: 5
      </option>
      <option value="3" selected="selected">
       Quantity: 6
      </option>
     </select>
    </td>
   </tr>
  </tbody>

You can provide a dict as new values::  

  >>> g = g.bind([bill, john], data={'User-1-email': 'bill_@example.com', 'User-1-password': '1234_', 'User-1-name': 'Bill_', 'User-1-orders': '1', 'User-2-email': 'john_@example.com', 'User-2-password': '5678_', 'User-2-name': 'John_', 'User-2-orders': ['2', '3'], })

Validation work like `Fieldset`::

  >>> g.validate()
  True

Sync too:

  >>> g.sync()
  >>> session.flush()
  >>> session.refresh(john)
  >>> john.email == 'john_@example.com'
  True
  >>> session.rollback()

And here is some other tests::  

  >>> g.rebind(data={'User-1-email': '', 'User-1-password': '1234_', 'User-1-name': 'Bill_', 'User-1-orders': '1', 'User-2-email': 'john_@example.com', 'User-2-password': '5678_', 'User-2-name': 'John_', 'User-2-orders': ['2', '3'], })

  >>> g.validate()
  False

  >>> g.errors[bill]
  {AttributeField(email): ['Please enter a value']}

  >>> g.errors[john]
  {}

  >>> g.sync_one(john)
  >>> session.flush()
  >>> session.refresh(john)

  >>> john.email == 'john_@example.com'
  True

  >>> session.rollback()

  >>> g = g.bind([john])
  >>> g.rows == [john]
  True

  >>> g.rebind(User)
  Traceback (most recent call last):
  ...
  Exception: instances must be an iterable, not <class 'formalchemy.tests.User'>

  >>> g = g.bind(User)
  Traceback (most recent call last):
  ...
  Exception: instances must be an iterable, not <class 'formalchemy.tests.User'>

